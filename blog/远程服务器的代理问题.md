 >参考开源项目nelvko/clash-for-linux-install.
 
##  安装
在终端中执行以下命令，即可完成 Clash 的下载、安装与基础配置。
```shell
# 开启ebcloud的学术加速
source /public/bin/network_accelerate
# git仓库并cd进对应文件夹
git clone --branch master --depth 1 https://github.com/nelvko/clash-for-linux-install.git
cd clash-for-linux-install
# 由于开启了学术加速，不使用 gh-proxy.org ，直接连接 GitHub 官方服务器通常更稳定、更安全。
sed -i 's|https://gh-proxy.org||g' .env 2>/dev/null
sed -i 's|https://gh-proxy.org||g' install.sh
# 执行下载的sh文件
bash install.sh
# 关闭学术加速
source /public/bin/network_accelerate_stop
```

```markdown
https://dash.knjc.cfd/api/v1/client/subscribe?token=a3bf795ae9fbca04056b2d4e74a38ac0
```


## 开启服务并验证
安装脚本执行完毕后，请按以下步骤开启服务并验证网络连通性：
```bash
# 1. 开启代理服务 (启动 Clash 内核并设置系统代理)
clashon

# 2. 测试加速效果 (若返回 HTTP/2 200 或类似响应头，说明连接成功)
curl -I https://www.google.com

# 3. 关闭代理服务 (停止内核并清除系统代理)
clashoff
```

> **说明**
> *   `clash: command not found` 错误：父子进程隔离导致的PATH变量找不到该命令 需重启shell或者执行`source ~/.bashrc`在父进程中更新规则。
> *   `netstat: command not found` 错误：安装 `net-tools` 工具包：
```bash
apt-get update && apt-get install net-tools -y
```

## TUN 模式
`TUN` 模式通过创建虚拟网卡，接管系统的所有网络流量（包括 Docker 等容器应用），并交由 Clash 核心进行处理，实现真正的全局代理。
```bash
# 查看 TUN 模式状态
$ clashtun
Tun 状态：关闭

# 开启 TUN 模式
$ clashtun on
Tun 模式已开启
```

##  卸载
如果需要移除本脚本及相关配置，请在项目根目录下执行卸载脚本。
```bash
bash uninstall.sh
```

---

## 知识点（gemini老师解说）


### 1. 环境变量 (Environment Variables) 与 PATH

**什么是环境变量？**
你可以把环境变量想象成操作系统的“全局设置”或者“便利贴”。它是 key-value（键-值）对的形式，比如 `HOME=/root`，告诉程序：“我的家目录在哪里”。任何程序启动时，都会看一眼这些便利贴，来决定自己怎么运行。

**什么是 PATH？**
`PATH` 是最著名的一个环境变量。它的作用是 **“寻宝地图”**。

当你在终端输入 `clashon` 并回车时，终端（Shell）并不知道 `clashon` 这个程序文件具体放在硬盘的哪个角落。它不会全盘扫描硬盘（那太慢了），而是去查看 `PATH` 变量。

`PATH` 的长相通常是这样的（用冒号分隔的一串目录）：
```text
PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin
```

**查找过程：**
1.  你输入 `clashon`。
2.  Shell 也就是你的终端，开始按照 `PATH` 里的顺序查找：
    *   先看 `/usr/local/bin` 里有没有 `clashon`？ -> 没有。
    *   再看 `/usr/bin` 里有没有？ -> 没有。
    *   再看 `/bin` 里有没有？ -> 没有。
3.  **结果**：全都找不到，于是报错：`command not found`。

**安装脚本做了什么？**
Clash 的安装脚本把 `clashon` 这个可执行文件放到了 `/root/clashctl` 目录下。为了让你能直接敲命令运行，它通常会在 `.bashrc` 文件里加一句：
```bash
export PATH=$PATH:/root/clashctl
```
意思是：在原有的地图上，追加一个新的地点 `/root/clashctl`。

---

### 2. 进程隔离 (Process Isolation)

这是操作系统最核心的安全机制之一。

**父子进程的关系**
在 Linux 中，程序的启动是通过“父子繁衍”的方式进行的。
*   **父进程**：你当前的终端窗口（比如 Bash，进程 ID 100）。
*   **子进程**：你在终端里敲下 `bash install.sh` 时，系统创建了一个新的 Bash 进程（进程 ID 101）来运行这个脚本。

**核心规则：内存隔离（沙盒）**
为了防止一个程序崩溃带崩整个系统，或者防止病毒程序随意修改其他程序的内存：
1.  **子进程继承父进程的环境**：子进程启动时，会拷贝一份父进程的环境变量（复印了一份地图）。
2.  **修改互不影响**：
    *   子进程在自己的内存里修改变量（在复印件上画了一笔），**父进程是完全不知道的**。
    *   子进程结束（脚本运行完毕），它的内存被回收，它手里那份修改过的地图（复印件）也就销毁了。

---

### 3. 为什么会出问题？（图解版）

让我们回到你的场景，看看发生了什么：

#### 第一阶段：你打开终端
*   **终端（父进程 PID 100）** 启动。
*   它读取 `.bashrc` 文件。
*   加载 `PATH` 变量到内存：`PATH=/bin:/usr/bin`。

#### 第二阶段：你运行 `bash install.sh`
*   终端创建了一个 **子进程（PID 101）** 来运行安装脚本。
*   **子进程** 拿到了 `PATH` 的副本。
*   **子进程** 做了两件事：
    1.  **修改文件**：它把 `export PATH=...` 这行字写入了硬盘上的 `.bashrc` 文件。（注意：硬盘改了，但父进程内存没改）。
    2.  **修改自己**：脚本运行过程中，可能临时修改了自己的 `PATH` 变量。
*   **子进程** 任务完成，**退出（死亡）**。

#### 第三阶段：回到终端（父进程）
*   你现在回到了 **终端（PID 100）**。
*   虽然硬盘上的 `.bashrc` 文件已经变了，但 **终端（PID 100）** 的内存里，`PATH` 依然是老样子：`PATH=/bin:/usr/bin`。
*   因为它不知道硬盘上的文件变了，它也不会自动去重读。
*   你输入 `clashon` -> 按照老地图找 -> 找不到 -> 报错。

---

### 4. 为什么 `source` 有用？

`source`（或者点号 `.`）是一个 **Shell 内置命令**，它**不是**一个新程序。

当你执行 `source ~/.bashrc` 时：
1.  系统 **不会** 创建子进程。
2.  系统直接在 **当前终端（父进程 PID 100）** 的内存里，逐行执行 `.bashrc` 里的命令。
3.  当读到 `export PATH=$PATH:/root/clashctl` 这一行时，它直接修改了 **当前终端内存里** 的 `PATH` 变量。

**总结：**
*   **`bash install.sh`**：是派个小弟（子进程）去干活，小弟改了规矩（文件），但他死了之后，老板（你）不知道新规矩。
*   **`source ~/.bashrc`**：是老板（你）亲自把新规矩（文件）读一遍，记在脑子（内存）里。